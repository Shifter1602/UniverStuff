#include <string.h>
#include "Notebook.h"


// конструктор 
// noteCount - максимальное количество записей, под которое будет выделена память
// unique - поддерживать ли уникальность содержимого, 
// т.е., чтобы не допускать несколько записей с одинаковыми фамилиями
Notebook::Notebook( int noteCount, bool unique )
{
	// создаем массив записей
	// проверку на корректность значения noteCount, например (noteCount > 0) не делаем,
	// потому что результат неуспешной проверки из конструктора возвращать сложно 
	notes = new Note[noteCount];

	// запоминаем, что у нас выделено noteCount количество записей
	reserved = noteCount;

	// запоминаем, что на данный момент записей нет
	count = 0;

	// запомним флаг уникальности
	this->unique = unique;
}

// деструктор
Notebook::~Notebook(void)
{
	// здесь нужно вручную осободить всю занятую динамическую память
	// а именно, это каждая запись, которая присутствует в книжке
	for( int i = 0; i < count; i++ )
	{
		delete[] notes[i].surname;
		delete[] notes[i].phone;
	}

	// после этого можно освобождать сам массив
	delete[] notes;
}

// метод добавления записи в книжку
// surname -  фамилия
// phone - номер телефона
// возвращаемое значение:
//  true - если запись была успешно вставлена
//  false - в противном случае
// этот метод не берет владение строками surname и phone, а копирует их
bool Notebook::Add( char *surname, char *phone )
{
	// прежде всего проверим, есть ли в массиве записей свободное место
	if( count >= reserved )
		return false;

	// если мы поддерживаем уникальность записей, проверим, 
	// нет ли записи с такой фамилией уже в списке
	if( Search( surname ) != 0 )
		return false;

	// если мы дошли досюда, то можем добавить запись в конец

	// выделим память для строк фамили и телефона в массиве
	// так как строки помимо символов должны содержать завершающий нулевой символ,
	// выделяем дополнительный + 1 байт
	notes[count].surname = new char[ strlen( surname ) + 1];
	notes[count].phone = new char[ strlen( phone ) + 1];

	// копируем содержимое переданных нам строк в наше созданное хранилище
	strcpy( notes[count].surname, surname );
	strcpy( notes[count].phone, phone );

	// увеличиваем счетчик заполненных записей
	count++;

	// отчитываемся, что запись вставлена успешно
	return true;
}

// удаление записи/записей
// surname - фамилия, запись/записи с котоорой следует удалить
// возвращаемое значение:
//  true - если запись была удалена/записи были удалены успешно
//  false - в противном случае
bool Notebook::Remove( char *surname )
{
	// проходим по массиву и удаляем все записи с данной фамилией,
	// сдвигая остальные так, чтобы они находились подряд

	// флаг того, что была удалена хотя бы одна запись
	bool hit = false;

	// индекс текущей записи в массиве при состоянии до удаления
	int old;
	// индекс текущей записи в массиве при состоянии после удаления
	int new_;
	// проходим по массиву двумя индексами
	// индекс old идет по исходному массиву, каждый раз сдвигается на следующую запись
	// индекс new_ указывает текущую позицию в массиве, 
	// полученном после удаления записей и сдвига оставшихся

	// когда мы встречаем запись с заданной фамилией, мы удаляем её данные,
	// шагаем индексом old на следующую, а индекс new_ не шагает,
	// таким образом мы пропускаем место, где была удаленная запись в массиве
	// так что при дальнейшем копировании записи из положения с индексом old 
	// положение с индексом new_, записи с заданной фамилией исключаются из итогового массива
	for( old = 0, new_ = 0; old < count; old++ )
	{
		// если строки равны, т.е. мы нашли искомую фамилию
		if( strcmp( notes[old].surname, surname ) == 0 )
		{
			// отмечаем, что запись была удалена
			hit = true;
			// удаляем запись с ней
			delete[] notes[old].surname;
			delete[] notes[old].phone;
		}
		else
		{
			if( new_ < old )
			{
				notes[new_].surname = notes[old].surname;
				notes[new_].phone = notes[old].phone;
			}
			new_++;
		}   
	}
	// запомним новоей количество записей в массиве
	count = new_;
	// вернем флаг того, была ли удалена хотя бы одна запись
	return hit;
}

// поиск записи с заданной фамилией
// surname - фамилия для поиска записи
// возвращаемое значение:
//  строка, содержащая телефон, если такая запись была найдена либо
//  0 - в противном случае
char *Notebook::Search( char *surname )
{
	// пройдемся по массиву записей и вернем телефон первой записи с фамилией, 
	// совпавшей с заданной
	for( int i = 0; i < count; i++ )
		if( strcmp( notes[i].surname, surname ) == 0 )
			return notes[i].phone;
	// если не было встречено ни одной такой записи, вернем признак неудачи
	return 0;
}