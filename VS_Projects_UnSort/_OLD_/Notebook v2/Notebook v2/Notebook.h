#pragma once

// класс записной книжки
class Notebook
{
public:
	// конструктор 
	// noteCount - максимальное количество записей, под которое будет выделена память
	// unique - поддерживать ли уникальность содержимого, 
	// т.е., чтобы не допускать несколько записей с одинаковыми фамилиями
	Notebook( int noteCount, bool unique );

	// деструктор
	~Notebook(void);

	// метод добавления записи в книжку
	// surname -  фамилия
	// phone - номер телефона
	// возвращаемое значение:
	//  true - если запись была успешно вставлена
	//  false - в противном случае
	// этот метод не берет владение строками surname и phone, а копирует их
	bool Add( char *surname, char *phone );

	// удаление записи/записей
	// surname - фамилия, запись/записи с котоорой следует удалить
	// возвращаемое значение:
	//  true - если запись была удалена/записи были удалены успешно
	//  false - в противном случае
	bool Remove( char *surname );

	// поиск записи с заданной фамилией
	// surname - фамилия для поиска записи
	// возвращаемое значение:
	//  строка, содержащая телефон, если такая запись была найдена либо
	//  0 - в противном случае
	char *Search( char *surname );

	// внутреннее представление
private:

	// структура одной записи в книжке - тип данных
	struct Note
	{
		char* surname;  // фамилия
		char* phone;    // номер телефона
	};

	// указатель на структуру типа Note
	// используется для организации массива записей и 
	// хранит указатель на первый элемент этого массива
	Note* notes;

	// количество записей, под которое выделена память, оно же
	// длина массива, оно же
	// максимально допустимое количество записей
	int reserved;

	// количество заполненных записей в массиве.
	// записи в массиве располагаются, начиная с индекса 0 и заканчивая индексом count - 1
	int count;

	// флаг, будем ли мы поддерживать уникальность записей,
	// т.е. что не будем допускать вставки нескольких записей с одной и той же фамилией
	bool unique;
};